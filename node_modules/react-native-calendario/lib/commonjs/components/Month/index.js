"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactNative = require("react-native");

var _reactNativeMonth = require("react-native-month");

var _moment = _interopRequireDefault(require("moment"));

var _date = require("../../utils/date");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SHOULD_NOT_UPDATE = true;

const EmptyMonth = /*#__PURE__*/_react.default.memo(props => /*#__PURE__*/_react.default.createElement(_reactNative.View, {
  style: [{
    height: props.height,
    justifyContent: 'center',
    alignItems: 'center'
  }, props.theme.emptyMonthContainerStyle]
}, /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
  style: [{
    fontSize: 25,
    fontWeight: '300'
  }, props.theme.emptyMonthTextStyle],
  allowFontScaling: false
}, props.name)), () => SHOULD_NOT_UPDATE);

const MonthTitle = /*#__PURE__*/_react.default.memo(props => /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
  allowFontScaling: false,
  style: [{
    textAlign: 'center',
    paddingVertical: 10
  }, props.theme.monthTitleTextStyle]
}, props.name), () => SHOULD_NOT_UPDATE);

var _default = /*#__PURE__*/_react.default.memo(props => {
  const {
    month,
    year,
    minDate,
    maxDate,
    showMonthTitle,
    monthNames,
    theme = {},
    height,
    locale,
    index
  } = props;
  const MONTH_NAMES = Array.isArray(monthNames) && monthNames.length === 12 ? monthNames : (0, _date.getMonthNames)(locale);
  const monthName = "".concat(MONTH_NAMES[month], " ").concat(year);

  if (index < props.firstViewableIndex - props.viewableRangeOffset || index > props.lastViewableIndex) {
    return /*#__PURE__*/_react.default.createElement(EmptyMonth, {
      name: monthName,
      height: height,
      theme: theme
    });
  }

  const min = minDate && (0, _date.isValidDate)(new Date(minDate)) ? (0, _moment.default)(minDate, 'YYYY-MM-DD').toDate() : undefined;
  const max = maxDate && (0, _date.isValidDate)(new Date(maxDate)) ? (0, _moment.default)(maxDate, 'YYYY-MM-DD').toDate() : undefined;
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: {
      height
    }
  }, showMonthTitle && /*#__PURE__*/_react.default.createElement(MonthTitle, {
    name: monthName,
    theme: theme
  }), /*#__PURE__*/_react.default.createElement(_reactNativeMonth.Month, {
    month: month,
    year: year,
    disabledDays: props.disabledDays,
    disableOffsetDays: props.disableOffsetDays,
    disableRange: props.disableRange,
    startDate: props.startDate,
    endDate: props.endDate,
    firstDayMonday: props.firstDayMonday,
    locale: props.locale,
    maxDate: max,
    minDate: min,
    onPress: props.onPress,
    renderDayContent: props.renderDayContent,
    showWeekdays: props.showWeekdays,
    theme: props.theme,
    dayNames: props.dayNames
  }));
}, (prevProps, nextProps) => {
  if (prevProps.disableRange !== nextProps.disableRange) {
    return false;
  }

  if ((prevProps.index < prevProps.firstViewableIndex - prevProps.viewableRangeOffset || prevProps.index > prevProps.lastViewableIndex) && nextProps.index >= nextProps.firstViewableIndex && nextProps.index <= nextProps.lastViewableIndex) {
    return false;
  }

  if ((!nextProps.dayNames || !nextProps.monthNames) && prevProps.locale !== nextProps.locale) {
    return false;
  }

  const currentMonth = (0, _moment.default)(nextProps.firstMonthToRender).add(nextProps.index, 'months');

  if (prevProps.disableRange === nextProps.disableRange) {
    if (nextProps.disableRange) {
      if (prevProps.startDate !== nextProps.startDate) {
        if (!prevProps.startDate && (0, _moment.default)(nextProps.startDate).isSame(currentMonth, 'month')) {
          return false;
        }

        if (prevProps.startDate && ((0, _moment.default)(prevProps.startDate).isSame(currentMonth, 'month') || (0, _moment.default)(nextProps.startDate).isSame(currentMonth, 'month'))) {
          return false;
        }
      }
    } else {
      const startDateChanged = prevProps.startDate instanceof Date && nextProps.startDate instanceof Date && !(0, _date.isSameDate)(prevProps.startDate, nextProps.startDate) || prevProps.startDate !== nextProps.startDate;
      const endDateChanged = prevProps.endDate instanceof Date && nextProps.endDate instanceof Date && !(0, _date.isSameDate)(prevProps.endDate, nextProps.endDate) || prevProps.endDate !== nextProps.endDate;

      if (startDateChanged || endDateChanged) {
        if ((0, _utils.isMonthDrawn)(currentMonth.year(), currentMonth.month(), prevProps.startDate, prevProps.endDate) !== (0, _utils.isMonthDrawn)(currentMonth.year(), currentMonth.month(), nextProps.startDate, nextProps.endDate) || prevProps.startDate instanceof Date && (0, _moment.default)(prevProps.startDate).isSame(currentMonth, 'month') && (startDateChanged || endDateChanged) || nextProps.startDate instanceof Date && (0, _moment.default)(nextProps.startDate).isSame(currentMonth, 'month') && startDateChanged || prevProps.endDate instanceof Date && (0, _moment.default)(prevProps.endDate).isSame(currentMonth, 'month') && endDateChanged || nextProps.endDate instanceof Date && (0, _moment.default)(nextProps.endDate).isSame(currentMonth, 'month') && endDateChanged) {
          return false;
        }
      }
    }
  } else {
    return false;
  }

  if ((0, _utils.shouldRenderMonth)(currentMonth, prevProps.minDate, nextProps.minDate) || (0, _utils.shouldRenderMonth)(currentMonth, prevProps.maxDate, nextProps.maxDate)) {
    return false;
  }

  return true;
});

exports.default = _default;
//# sourceMappingURL=index.js.map