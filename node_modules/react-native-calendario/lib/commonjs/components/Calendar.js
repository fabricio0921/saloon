"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _moment = _interopRequireDefault(require("moment"));

var _Month = _interopRequireDefault(require("./Month"));

var _date = require("../utils/date");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const NUMBER_OF_MONTHS = 12;
const MONTH_HEIGHT = 370;
const INITIAL_LIST_SIZE = 2;
const VIEWABLE_RANGE_OFFSET = 5;
const VIEWABILITY_CONFIG = {
  waitForInteraction: true,
  itemVisiblePercentThreshold: 10,
  minimumViewTime: 32
};

class Calendar extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "listReference", void 0);

    _defineProperty(this, "getItemLayout", (_data, index) => ({
      length: this.props.monthHeight,
      offset: this.props.monthHeight * index,
      index
    }));

    _defineProperty(this, "keyExtractor", (_item, index) => String(index));

    _defineProperty(this, "handleViewableItemsChange", info => {
      if (this.props.viewableItemsChanged) {
        this.props.viewableItemsChanged(info);
      }

      const {
        viewableItems
      } = info;

      if (viewableItems.length > 0) {
        const {
          0: firstViewableItem,
          length: l,
          [l - 1]: lastViewableItem
        } = viewableItems;
        const {
          firstViewableIndex,
          lastViewableIndex
        } = this.state;

        if (firstViewableIndex !== firstViewableItem.index || lastViewableIndex !== lastViewableItem.index) {
          this.setState({
            firstViewableIndex: firstViewableItem.index,
            lastViewableIndex: lastViewableItem.index + VIEWABLE_RANGE_OFFSET
          });
        }
      }
    });

    _defineProperty(this, "handlePressDay", date => {
      const {
        startDate,
        endDate
      } = this.state;
      let newStartDate;
      let newEndDate;

      if (this.props.disableRange) {
        newStartDate = date;
        newEndDate = undefined;
      } else if (startDate) {
        if (endDate) {
          newStartDate = date;
          newEndDate = undefined;
        } else if (date < startDate) {
          newStartDate = date;
        } else if (date > startDate) {
          newStartDate = startDate;
          newEndDate = date;
        } else {
          newStartDate = date;
          newEndDate = date;
        }
      } else {
        newStartDate = date;
      }

      const newRange = {
        startDate: newStartDate,
        endDate: newEndDate
      };
      this.setState(newRange, () => this.props.onChange(newRange));
    });

    _defineProperty(this, "setReference", ref => {
      if (ref) {
        this.listReference = ref;

        if (this.props.calendarListRef) {
          this.props.calendarListRef(ref);
        }
      }
    });

    _defineProperty(this, "getMonthIndex", (date, months, firstMonthToRender) => {
      const {
        numberOfMonths
      } = this.props;
      const firstMonth = (0, _moment.default)(firstMonthToRender);
      const lastMonth = firstMonth.clone().add(numberOfMonths, 'months');

      if (date >= firstMonth.toDate() && date <= lastMonth.endOf('month').toDate()) {
        const monthIndex = (0, _moment.default)(date).diff(firstMonth, 'months');

        if (monthIndex >= 0 && monthIndex <= months.length) {
          return monthIndex;
        }
      }

      return null;
    });

    _defineProperty(this, "renderMonth", ({
      index
    }) => {
      const {
        firstMonthToRender
      } = this.state;
      const month = (0, _moment.default)(firstMonthToRender).add(index, 'months');
      return /*#__PURE__*/React.createElement(_Month.default, {
        month: month.month(),
        year: month.year(),
        index: index,
        firstMonthToRender: this.state.firstMonthToRender,
        monthNames: this.props.monthNames,
        onPress: this.handlePressDay,
        theme: this.props.theme,
        showWeekdays: this.props.showWeekdays,
        showMonthTitle: this.props.showMonthTitle,
        locale: this.props.locale,
        dayNames: this.props.dayNames,
        height: this.props.monthHeight,
        firstDayMonday: this.props.firstDayMonday,
        renderDayContent: this.props.renderDayContent,
        minDate: this.props.minDate,
        maxDate: this.props.maxDate,
        startDate: this.state.startDate,
        endDate: this.state.endDate,
        disableRange: this.props.disableRange,
        disabledDays: this.props.disabledDays,
        disableOffsetDays: this.props.disableOffsetDays,
        firstViewableIndex: this.state.firstViewableIndex,
        lastViewableIndex: this.state.lastViewableIndex,
        viewableRangeOffset: this.props.viewableRangeOffset
      });
    });

    this.state = {
      firstMonthToRender: new Date(),
      months: [],
      initialScrollIndex: 0,
      startDate: undefined,
      endDate: undefined,
      firstViewableIndex: 0,
      lastViewableIndex: INITIAL_LIST_SIZE + props.viewableRangeOffset
    };
  }

  UNSAFE_componentWillMount() {
    const {
      numberOfMonths,
      startingMonth,
      startDate,
      endDate
    } = this.props;
    let {
      firstMonthToRender
    } = this.state;

    if (startingMonth && (0, _date.isValidDate)(new Date(startingMonth))) {
      firstMonthToRender = (0, _moment.default)(startingMonth, 'YYYY-MM-DD').toDate();
    }

    let start;

    if (startDate && (0, _date.isValidDate)(new Date(startDate))) {
      start = (0, _moment.default)(startDate, 'YYYY-MM-DD').toDate();

      if (start > (0, _moment.default)(firstMonthToRender).add(numberOfMonths, 'months').toDate()) {
        start = undefined;
      }
    }

    const end = endDate && (0, _date.isValidDate)(new Date(endDate)) ? (0, _moment.default)(endDate, 'YYYY-MM-DD').toDate() : undefined;
    const months = new Array(numberOfMonths);
    let firstMonthIndex = 0;

    if (start) {
      const monthIndex = this.getMonthIndex(start, months, firstMonthToRender);

      if (monthIndex !== null) {
        firstMonthIndex = monthIndex;
      }
    }

    this.setState({
      firstMonthToRender,
      initialScrollIndex: firstMonthIndex,
      months,
      startDate: start,
      endDate: end
    });
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    const {
      startDate,
      months,
      firstMonthToRender
    } = this.state;
    const nextStartDate = nextProps.startDate && nextProps.startDate instanceof Date ? nextProps.startDate : undefined;
    const endDate = nextProps.endDate && nextProps.endDate instanceof Date ? nextProps.endDate : undefined;

    if (startDate !== nextStartDate || this.state.endDate !== endDate) {
      this.setState({
        startDate: nextStartDate,
        endDate
      }, () => {
        if (this.listReference && nextStartDate && startDate !== nextStartDate) {
          const monthIndex = this.getMonthIndex(nextStartDate, months, firstMonthToRender);

          if (monthIndex !== null) {
            this.listReference.scrollToIndex({
              index: monthIndex
            });
          }
        }
      });
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    return this.state.months.length !== nextState.months.length || this.state.startDate !== nextState.startDate || this.state.firstViewableIndex !== nextState.firstViewableIndex || this.state.lastViewableIndex !== nextState.lastViewableIndex || this.state.endDate !== nextState.endDate || this.props.minDate !== nextProps.minDate || this.props.maxDate !== nextProps.maxDate || this.props.startingMonth !== nextProps.startingMonth || this.props.renderDayContent !== nextProps.renderDayContent;
  }

  render() {
    return /*#__PURE__*/React.createElement(_reactNative.FlatList, {
      getItemLayout: this.getItemLayout,
      initialScrollIndex: this.state.initialScrollIndex,
      viewabilityConfig: VIEWABILITY_CONFIG,
      removeClippedSubviews: true,
      onViewableItemsChanged: this.handleViewableItemsChange,
      initialNumToRender: this.props.initialListSize,
      keyExtractor: this.keyExtractor,
      renderItem: this.renderMonth,
      extraData: { ...this.state,
        minDate: this.props.minDate,
        maxDate: this.props.maxDate
      },
      data: this.state.months,
      ref: this.setReference
    });
  }

}

exports.default = Calendar;

_defineProperty(Calendar, "defaultProps", {
  numberOfMonths: NUMBER_OF_MONTHS,
  startingMonth: (0, _moment.default)().format('YYYY-MM-DD'),
  initialListSize: INITIAL_LIST_SIZE,
  showWeekdays: true,
  showMonthTitle: true,
  theme: {},
  locale: 'en',
  monthNames: [],
  dayNames: [],
  disableRange: false,
  firstDayMonday: false,
  monthHeight: MONTH_HEIGHT,
  disableOffsetDays: false,
  viewableRangeOffset: VIEWABLE_RANGE_OFFSET
});
//# sourceMappingURL=Calendar.js.map