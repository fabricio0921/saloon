function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import * as React from 'react';
import { FlatList } from 'react-native';
import moment from 'moment';
import Month from './Month';
import { isValidDate } from '../utils/date';
const NUMBER_OF_MONTHS = 12;
const MONTH_HEIGHT = 370;
const INITIAL_LIST_SIZE = 2;
const VIEWABLE_RANGE_OFFSET = 5;
const VIEWABILITY_CONFIG = {
  waitForInteraction: true,
  itemVisiblePercentThreshold: 10,
  minimumViewTime: 32
};
export default class Calendar extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "listReference", void 0);

    _defineProperty(this, "getItemLayout", (_data, index) => ({
      length: this.props.monthHeight,
      offset: this.props.monthHeight * index,
      index
    }));

    _defineProperty(this, "keyExtractor", (_item, index) => String(index));

    _defineProperty(this, "handleViewableItemsChange", info => {
      if (this.props.viewableItemsChanged) {
        this.props.viewableItemsChanged(info);
      }

      const {
        viewableItems
      } = info;

      if (viewableItems.length > 0) {
        const {
          0: firstViewableItem,
          length: l,
          [l - 1]: lastViewableItem
        } = viewableItems;
        const {
          firstViewableIndex,
          lastViewableIndex
        } = this.state;

        if (firstViewableIndex !== firstViewableItem.index || lastViewableIndex !== lastViewableItem.index) {
          this.setState({
            firstViewableIndex: firstViewableItem.index,
            lastViewableIndex: lastViewableItem.index + VIEWABLE_RANGE_OFFSET
          });
        }
      }
    });

    _defineProperty(this, "handlePressDay", date => {
      const {
        startDate,
        endDate
      } = this.state;
      let newStartDate;
      let newEndDate;

      if (this.props.disableRange) {
        newStartDate = date;
        newEndDate = undefined;
      } else if (startDate) {
        if (endDate) {
          newStartDate = date;
          newEndDate = undefined;
        } else if (date < startDate) {
          newStartDate = date;
        } else if (date > startDate) {
          newStartDate = startDate;
          newEndDate = date;
        } else {
          newStartDate = date;
          newEndDate = date;
        }
      } else {
        newStartDate = date;
      }

      const newRange = {
        startDate: newStartDate,
        endDate: newEndDate
      };
      this.setState(newRange, () => this.props.onChange(newRange));
    });

    _defineProperty(this, "setReference", ref => {
      if (ref) {
        this.listReference = ref;

        if (this.props.calendarListRef) {
          this.props.calendarListRef(ref);
        }
      }
    });

    _defineProperty(this, "getMonthIndex", (date, months, firstMonthToRender) => {
      const {
        numberOfMonths
      } = this.props;
      const firstMonth = moment(firstMonthToRender);
      const lastMonth = firstMonth.clone().add(numberOfMonths, 'months');

      if (date >= firstMonth.toDate() && date <= lastMonth.endOf('month').toDate()) {
        const monthIndex = moment(date).diff(firstMonth, 'months');

        if (monthIndex >= 0 && monthIndex <= months.length) {
          return monthIndex;
        }
      }

      return null;
    });

    _defineProperty(this, "renderMonth", ({
      index
    }) => {
      const {
        firstMonthToRender
      } = this.state;
      const month = moment(firstMonthToRender).add(index, 'months');
      return /*#__PURE__*/React.createElement(Month, {
        month: month.month(),
        year: month.year(),
        index: index,
        firstMonthToRender: this.state.firstMonthToRender,
        monthNames: this.props.monthNames,
        onPress: this.handlePressDay,
        theme: this.props.theme,
        showWeekdays: this.props.showWeekdays,
        showMonthTitle: this.props.showMonthTitle,
        locale: this.props.locale,
        dayNames: this.props.dayNames,
        height: this.props.monthHeight,
        firstDayMonday: this.props.firstDayMonday,
        renderDayContent: this.props.renderDayContent,
        minDate: this.props.minDate,
        maxDate: this.props.maxDate,
        startDate: this.state.startDate,
        endDate: this.state.endDate,
        disableRange: this.props.disableRange,
        disabledDays: this.props.disabledDays,
        disableOffsetDays: this.props.disableOffsetDays,
        firstViewableIndex: this.state.firstViewableIndex,
        lastViewableIndex: this.state.lastViewableIndex,
        viewableRangeOffset: this.props.viewableRangeOffset
      });
    });

    this.state = {
      firstMonthToRender: new Date(),
      months: [],
      initialScrollIndex: 0,
      startDate: undefined,
      endDate: undefined,
      firstViewableIndex: 0,
      lastViewableIndex: INITIAL_LIST_SIZE + props.viewableRangeOffset
    };
  }

  UNSAFE_componentWillMount() {
    const {
      numberOfMonths,
      startingMonth,
      startDate,
      endDate
    } = this.props;
    let {
      firstMonthToRender
    } = this.state;

    if (startingMonth && isValidDate(new Date(startingMonth))) {
      firstMonthToRender = moment(startingMonth, 'YYYY-MM-DD').toDate();
    }

    let start;

    if (startDate && isValidDate(new Date(startDate))) {
      start = moment(startDate, 'YYYY-MM-DD').toDate();

      if (start > moment(firstMonthToRender).add(numberOfMonths, 'months').toDate()) {
        start = undefined;
      }
    }

    const end = endDate && isValidDate(new Date(endDate)) ? moment(endDate, 'YYYY-MM-DD').toDate() : undefined;
    const months = new Array(numberOfMonths);
    let firstMonthIndex = 0;

    if (start) {
      const monthIndex = this.getMonthIndex(start, months, firstMonthToRender);

      if (monthIndex !== null) {
        firstMonthIndex = monthIndex;
      }
    }

    this.setState({
      firstMonthToRender,
      initialScrollIndex: firstMonthIndex,
      months,
      startDate: start,
      endDate: end
    });
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    const {
      startDate,
      months,
      firstMonthToRender
    } = this.state;
    const nextStartDate = nextProps.startDate && nextProps.startDate instanceof Date ? nextProps.startDate : undefined;
    const endDate = nextProps.endDate && nextProps.endDate instanceof Date ? nextProps.endDate : undefined;

    if (startDate !== nextStartDate || this.state.endDate !== endDate) {
      this.setState({
        startDate: nextStartDate,
        endDate
      }, () => {
        if (this.listReference && nextStartDate && startDate !== nextStartDate) {
          const monthIndex = this.getMonthIndex(nextStartDate, months, firstMonthToRender);

          if (monthIndex !== null) {
            this.listReference.scrollToIndex({
              index: monthIndex
            });
          }
        }
      });
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    return this.state.months.length !== nextState.months.length || this.state.startDate !== nextState.startDate || this.state.firstViewableIndex !== nextState.firstViewableIndex || this.state.lastViewableIndex !== nextState.lastViewableIndex || this.state.endDate !== nextState.endDate || this.props.minDate !== nextProps.minDate || this.props.maxDate !== nextProps.maxDate || this.props.startingMonth !== nextProps.startingMonth || this.props.renderDayContent !== nextProps.renderDayContent;
  }

  render() {
    return /*#__PURE__*/React.createElement(FlatList, {
      getItemLayout: this.getItemLayout,
      initialScrollIndex: this.state.initialScrollIndex,
      viewabilityConfig: VIEWABILITY_CONFIG,
      removeClippedSubviews: true,
      onViewableItemsChanged: this.handleViewableItemsChange,
      initialNumToRender: this.props.initialListSize,
      keyExtractor: this.keyExtractor,
      renderItem: this.renderMonth,
      extraData: { ...this.state,
        minDate: this.props.minDate,
        maxDate: this.props.maxDate
      },
      data: this.state.months,
      ref: this.setReference
    });
  }

}

_defineProperty(Calendar, "defaultProps", {
  numberOfMonths: NUMBER_OF_MONTHS,
  startingMonth: moment().format('YYYY-MM-DD'),
  initialListSize: INITIAL_LIST_SIZE,
  showWeekdays: true,
  showMonthTitle: true,
  theme: {},
  locale: 'en',
  monthNames: [],
  dayNames: [],
  disableRange: false,
  firstDayMonday: false,
  monthHeight: MONTH_HEIGHT,
  disableOffsetDays: false,
  viewableRangeOffset: VIEWABLE_RANGE_OFFSET
});
//# sourceMappingURL=Calendar.js.map